El presente informe se enmarca en el campo del \textbf{Análisis y Diseño de Algoritmos} en Ciencias de la Computación, disciplina fundamental que estudia tanto la eficiencia teórica como el comportamiento práctico de las soluciones algorítmicas a problemas computacionales. El estudio de algoritmos permite optimizar recursos computacionales críticos, como el tiempo de ejecución y el consumo de memoria, elementos esenciales en el desarrollo de aplicaciones eficientes a gran escala. Durante décadas, investigaciones clásicas como las de Cormen et al. han establecido las bases del análisis asintótico; sin embargo, en la práctica, el rendimiento real puede diferir significativamente del comportamiento predicho, especialmente cuando se consideran factores como la estructura de los datos, el entorno de ejecución o los costos de acceso a memoria.

En este contexto, surge una \textbf{brecha} relevante entre el análisis teórico y el comportamiento experimental de los algoritmos. Si bien la notación asintótica (por ejemplo, $\mathcal{O}(n\log n)$ o $\mathcal{O}(n^2)$) proporciona información sobre la tendencia de crecimiento para entradas grandes, no siempre refleja de manera precisa la eficiencia en tamaños de entrada típicos en aplicaciones reales. Este informe busca precisamente explorar esa diferencia, enfocándose en algoritmos de \textbf{ordenamiento} (Merge Sort, Quick Sort y Selection Sort) y \textbf{multiplicación de matrices} (Naive y Strassen), evaluando su comportamiento práctico frente a distintos tipos de matrices (densas, diagonales y dispersas).

El propósito principal de este estudio es comparar experimentalmente estos algoritmos en términos de \textbf{tiempo de ejecución} y \textbf{consumo de memoria}, utilizando un entorno controlado que permita garantizar la \textbf{reproducibilidad} de los resultados. A diferencia del tratamiento meramente teórico abordado en clases, aquí se pretende validar, mediante experimentación sistemática, cómo se manifiestan en la práctica las diferencias de eficiencia entre algoritmos, y en qué condiciones un algoritmo puede resultar preferible a otro.